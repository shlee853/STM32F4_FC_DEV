/*
 * W25Qxx_Flash.c
 *
 *  Created on: Feb 26, 2023
 *      Author: swift
 */


#include "W25Qxx_Flash.h"



void W25Qxx_GPIO_SPI_Initialization(void)
{
	LL_SPI_Enable(W25Qxx_SPI_CHANNEL);
	CHIP_DESELECT(W25Qxx);
}


unsigned char SPI1_SendByte(unsigned char data)
{
	while(LL_SPI_IsActiveFlag_TXE(W25Qxx_SPI_CHANNEL)==RESET);
	LL_SPI_TransmitData8(W25Qxx_SPI_CHANNEL, data);

	while(LL_SPI_IsActiveFlag_RXNE(W25Qxx_SPI_CHANNEL)==RESET);
	return LL_SPI_ReceiveData8(W25Qxx_SPI_CHANNEL);
}

//////////////////////////////////////////////////////////////

uint8_t W25Qxx_Readbyte(uint8_t reg_addr)
{
	uint8_t val;

	CHIP_SELECT(W25Qxx);
	SPI1_SendByte(reg_addr | 0x80); //Register. MSB 1 is read instruction.
	val = SPI1_SendByte(0x00); //Send DUMMY to read data
	CHIP_DESELECT(W25Qxx);

	return val;
}

void W25Qxx_Readbytes(unsigned char reg_addr, unsigned char len, unsigned char* data)
{
	unsigned int i = 0;

	CHIP_SELECT(W25Qxx);
	SPI1_SendByte(reg_addr | 0x80); //Register. MSB 1 is read instruction.
	while(i < len)
	{
		data[i++] = SPI1_SendByte(0x00); //Send DUMMY to read data
	}
	CHIP_DESELECT(W25Qxx);
}

void W25Qxx_Writebyte(uint8_t reg_addr, uint8_t val)
{
	CHIP_SELECT(W25Qxx);
	SPI1_SendByte(reg_addr & 0x7F); //Register. MSB 0 is write instruction.
	SPI1_SendByte(val); //Send Data to write
	CHIP_DESELECT(W25Qxx);
}

void W25Qxx_Writebytes(unsigned char reg_addr, unsigned char len, unsigned char* data)
{
	unsigned int i = 0;
	CHIP_SELECT(W25Qxx);
	SPI1_SendByte(reg_addr & 0x7F); //Register. MSB 0 is write instruction.
	while(i < len)
	{
		SPI1_SendByte(data[i++]); //Send Data to write
	}
	CHIP_DESELECT(W25Qxx);
}


int W25Qxx_Initialization(void)
{

	uint8_t who_am_i = 0;
	int16_t accel_raw_data[3] = {0};  // To remove offset
	int16_t gyro_raw_data[3] = {0};   // To remove offset

	W25Qxx_GPIO_SPI_Initialization();

	printf("Checking W25Qxx...");

	// check WHO_AM_I (0x75)
	who_am_i = W25Qxx_Readbyte(WHO_AM_I);

	// who am i = 0x12
	if(who_am_i == 0x12)
	{
		printf("\r\nW25Qxx who_am_i = 0x%02x...OK\n\n", who_am_i);
	}
	// recheck
	else if(who_am_i != 0x12)
	{
		who_am_i = W25Qxx_Readbyte(WHO_AM_I); // check again WHO_AM_I (0x75)

		if (who_am_i != 0x12){
			printf( "W25Qxx Not OK: 0x%02x Should be 0x%02x\n", who_am_i, 0x12);
			return 1; //ERROR
		}
	}

	// Reset W25Qxx
	// PWR_MGMT_1 0x6B
	W25Qxx_Writebyte(PWR_MGMT_1, 0x80); //Reset W25Qxx
	usDelay(50000);

	// PWR_MGMT_1 0x6B
	W25Qxx_Writebyte(PWR_MGMT_1, 0x01); // Enable Temperature sensor(bit4-0), Use PLL(bit2:0-01)
									// 온도센서 끄면 자이로 값 이상하게 출력됨
	usDelay(50000);

	// PWR_MGMT_2 0x6C
	//W25Qxx_Writebyte(PWR_MGMT_2, 0x38); // Disable Acc(bit5:3-111), Enable Gyro(bit2:0-000)
	W25Qxx_Writebyte( PWR_MGMT_2, 0x00 ); // Enable Acc(bit5:3-000), Enable Gyro(bit2:0-000)
	usDelay(50000);

	// set sample rate to 1000Hz and apply a software filter
	W25Qxx_Writebyte(SMPLRT_DIV, 0x00);
	usDelay(50000);

	// Gyro DLPF Config
//	W25Qxx_Writebyte(CONFIG, 0x00); // Gyro LPF fc 250Hz(bit2:0-000)
	W25Qxx_Writebyte(CONFIG, 0x05); // Gyro LPF fc 20Hz(bit2:0-100) at 1kHz sample rate
	usDelay(50000);

	// GYRO_CONFIG 0x1B
	W25Qxx_Writebyte(GYRO_CONFIG, 0x18); // Gyro sensitivity 2000 dps(bit4:3-11), FCHOICE (bit1:0-00)
	usDelay(50000);

	// ACCEL_CONFIG 0x1C
	W25Qxx_Writebyte(ACCEL_CONFIG, 0x18); // Acc sensitivity 16g
	usDelay(50000);

	// ACCEL_CONFIG2 0x1D
	W25Qxx_Writebyte(ACCEL_CONFIG2, 0x03); // Acc FCHOICE 1kHz(bit3-0), DLPF fc 44.8Hz(bit2:0-011)
	usDelay(50000);

	// Enable Interrupts when data is ready
	W25Qxx_Writebyte(INT_ENABLE, 0x01); // Enable DRDY Interrupt
	usDelay(50000);

	//printf("gyro bias: %d %d %d\n", gyro_x_offset, gyro_y_offset, gyro_z_offset);

	// Remove Gyro X offset
//	W25Qxx_Writebyte( XG_OFFS_USRH, offset_x>>8 );	// gyro x offset high byte
//	W25Qxx_Writebyte( XG_OFFS_USRL, offset_x );	// gyro x offset low byte
//
//	// Remove Gyro Y offset
//	W25Qxx_Writebyte( YG_OFFS_USRH, offset_y>>8 );	// gyro y offset high byte
//	W25Qxx_Writebyte( YG_OFFS_USRL, offset_y );	// gyro y offset low byte
//
//	// Remove Gyro Z offset
//	W25Qxx_Writebyte( ZG_OFFS_USRH, offset_z>>8 );	// gyro z offset high byte
//	W25Qxx_Writebyte( ZG_OFFS_USRL, offset_z );	// gyro z offset low byte

	return 0; //OK
}

void W25Qxx_Get6AxisRawData(short* accel, short* gyro)
{
	unsigned char data[14];
	W25Qxx_Readbytes(ACCEL_XOUT_H, 14, data);

	accel[0] = (data[0] << 8) | data[1];
	accel[1] = (data[2] << 8) | data[3];
	accel[2] = (data[4] << 8) | data[5];

	gyro[0] = ((data[8] << 8) | data[9]);
	gyro[1] = ((data[10] << 8) | data[11]);
	gyro[2] = ((data[12] << 8) | data[13]);
}

void W25Qxx_Get3AxisGyroRawData(short* gyro)
{
	unsigned char data[6];
	W25Qxx_Readbytes(GYRO_XOUT_H, 6, data);

	gyro[0] = ((data[0] << 8) | data[1]);
	gyro[1] = ((data[2] << 8) | data[3]);
	gyro[2] = ((data[4] << 8) | data[5]);
}

void W25Qxx_Get3AxisAccRawData(short* accel)
{
	unsigned char data[6];
	W25Qxx_Readbytes(ACCEL_XOUT_H, 6, data);

	accel[0] = ((data[0] << 8) | data[1]);
	accel[1] = ((data[2] << 8) | data[3]);
	accel[2] = ((data[4] << 8) | data[5]);
}

int W25Qxx_DataReady(void)
{
	return LL_GPIO_IsInputPinSet(W25Qxx_INT_PORT, W25Qxx_INT_PIN);
}
